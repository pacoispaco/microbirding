#!/usr/bin/env python

"""This is the SthlmBetong web app."""

# FastAPI and Pydantic
from fastapi import FastAPI, status, Request, Query
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from pydantic_settings import BaseSettings
# Basic Python modules
from typing import Optional
import sys
import os.path
import locale
import json
import atexit
import logging
import logging.config
import time
from datetime import date as dt, timedelta
from datetime import datetime as dtime
# Application modules
import artportalen

# Constants
secrets = ["ARTPORTALEN_OBSERVATIONS_API_KEY",
           "ARTPORTALEN_SPECIES_API_KEY"]
# We read the local RELEASE_TAG_FILE and a BUILD_DATETIME_TAG that should be generated by the CI/CD
# build script(s).
RELEASE_TAG_FILE = "./RELEASE_TAG_FILE"
BUILD_DATETIME_FILE = "./BUILD_DATETIME_FILE"


logger = logging.getLogger(__name__)


def get_handler_by_name(name: str):
    """This can be removed in Python 3.12 since there we have logging.getHandlerByName."""
    for logger_name in logging.root.manager.loggerDict:
        logger = logging.getLogger(logger_name)
        for handler in logger.handlers:
            if handler.name == name:
                return handler
    # also check root logger
    for handler in logging.getLogger().handlers:
        if handler.name == name:
            return handler
    return None


def setup_logging(config_filepath):
    """Set up logging. If no logging config file is found, set up default logging."""
    if os.path.exists(config_filepath):
        with open(config_filepath) as f:
            config = json.load(f)
        logging.config.dictConfig(config)
#        queue_handler = logging.getHandlerByName("queue_handler")
        queue_handler = get_handler_by_name("queue_handler")
        if queue_handler is not None:
            queue_handler.listener.start()
            atexit.register(queue_handler.listener.stop)
    else:
        logger.setLevel("DEBUG")
        logger.warning(f"Configuration file '{config_filepath}' for logging not found. "
                       "Using default logging settings.")


def release_tag():
    """Return the release tag."""
    if os.path.exists(RELEASE_TAG_FILE):
        with open(RELEASE_TAG_FILE) as f:
            return f.read().strip()
    else:
        return "No RELEASE_TAG_FILE found"


def build_datetime_tag():
    """Return the build datetime tag."""
    if os.path.exists(BUILD_DATETIME_FILE):
        with open(BUILD_DATETIME_FILE) as f:
            return f.read().strip()
    else:
        return "No BUILD_DATETIME_FILE found"


def file_secret_as_env(var_name: str):
    """Reads a secret from a textfile - if that file exists - and then ads the secret to the
       "environment" of this program. This is used to enable this program to read secrets from
       textfiles when it is packaged as a Docker image and run as a Docker container."""
    # The convention for Docker compose files is to name these files *_FILE and provide that name
    # and its value - a file path - as an environment variable.
    file_var = f"{var_name}_FILE"
    if file_path := os.getenv(file_var):
        with open(file_path) as f:
            value = f.read().strip()
            os.environ[var_name] = value


# Read in the secrets from files, if they exist, as environment variables. They will then be picked
# up by Settings below.
[file_secret_as_env(var) for var in secrets]


class Settings(BaseSettings):
    """Provides configuration and environment variables via the Pydantic BaseSettings class. Values
       are read in this order:
       1) Environment variables. If they are not set then from
       2) Key/values from a ".env" file. If they are not set there then from
       3) Default values set in this class."""
    VERSION: str = "0.0.1"
    TEMPLATES_DIR: str = "templates"
    DATE_FORMAT: str = "Date: %a, %d %b %Y %H:%M:%S"
    ARTPORTALEN_OBSERVATIONS_API_KEY: Optional[str] = None
    ARTPORTALEN_SPECIES_API_KEY: Optional[str] = None
    POLYGON_FILE: str = "./conf/polygon.sthlmbetong.json"
    DEFAULT_TAXON_SEARCH_ID: int = 4000104  # Id of the taxon "Aves" in the Artportalen Species API.
    DEFAULT_NUMBER_OF_OBSERVATIONS: int = 50
    LOGGING_CONFIG_FILE: str = "./conf/logging-config.json"

    class ConfigDict:
        env_file = ".env"


def polygon_coordinates(filename):
    """The list of polygon coordinates in WGS84 from the file `filename` to use when searching
       for observations in the Artportalen Observations API. Return None if it fails."""
    result = None
    if not os.path.exists(filename):
        settings.logger.error(f"Polygon file {filename} not found.")
    else:
        with open(filename) as f:
            try:
                result = json.load(f)
            except json.decoder.JSONDecodeError:
                settings.logger.error(f"Polygon file {filename} is not a valid JSON file.")
    return result


# Set up some application globals
settings = Settings()
setup_logging(settings.LOGGING_CONFIG_FILE)
if not settings.ARTPORTALEN_OBSERVATIONS_API_KEY:
    settings.logger.error("Environment variable 'ARTPORTALEN_OBSERVATIONS_API_KEY' not set")
    sys.exit(1)
if not settings.ARTPORTALEN_SPECIES_API_KEY:
    settings.logger.error("Environment variable 'ARTPORTALEN_SPECIES_API_KEY' not set")
    sys.exit(2)
if not settings.POLYGON_FILE:
    settings.logger.error("Environment variable 'POLYGON_FILE' not set")
    sys.exit(3)
templates = Jinja2Templates(directory=settings.TEMPLATES_DIR)
sapi = artportalen.SpeciesAPI(settings.ARTPORTALEN_SPECIES_API_KEY)
oapi = artportalen.ObservationsAPI(settings.ARTPORTALEN_OBSERVATIONS_API_KEY)
polygon = polygon_coordinates(settings.POLYGON_FILE)
if not polygon:
    settings.logger.error(f"Failed to read polygon coordinates from {settings.POLYGON_FILE}.")
locale.setlocale(locale.LC_TIME, 'sv_SE.UTF-8')
logger.info("Application initialized.")


def get_observations(from_date, to_date, taxon_name=None, observer_name=None):
    """Get observations from the Artportalen API, make them tidy and consumable by the Jinja2
       templates and put them into a list."""
    # Get the taxa ids that match the given `taxon_name`.
    taxon_ids = [settings.DEFAULT_TAXON_SEARCH_ID]
    if taxon_name:
        taxa = sapi.taxa_by_name(taxon_name,
                                 exact_match=True)
        if not taxa:
            settings.debug(f"No taxa matching {taxon_name} found in Artportalen Species API")
        else:
            taxon_ids = [t["taxonId"] for t in taxa]

    # Set up the search filter for the Artportalen Observations API
    sfilter = artportalen.SearchFilter()
    sfilter.set_taxon(ids=taxon_ids)
    sfilter.set_geographics_geometries(geometries=[{"type": "polygon",
                                                    "coordinates": [polygon]}])
    sfilter.set_verification_status()
    sfilter.set_output()
    sfilter.set_date(startDate=from_date,
                     endDate=to_date,
                     dateFilterType="OverlappingStartDateAndEndDate",
                     timeRanges=[])
    sfilter.set_modified_date()
    sfilter.set_dataProvider()
    observations = oapi.observations(sfilter,
                                     skip=0,
                                     take=1000,
                                     sort_descending=True)
    return observations


def summarized_taxa_info(name,
                         is_redlisted=False,
                         redlist_category=None,
                         sex=None,
                         number=None,
                         age=None,
                         activity=None):
    """Formatted string with taxa info on observation, for Jinja2 to use in UI presentation.
       Eg. 'Östersjötrut, 1 födosökande'."""
    result = f"{name}"
    if number or sex or age or activity:
        result += ","
    if number:
        result += f" {number}"
    if age:
        result += f" {age}"
    if sex:
        result += f" {sex}"
    if activity:
        result += f" {activity}"
    if is_redlisted:
        result += f" ({redlist_category})"
    return result.strip(",")


def transformed_observations(artportalen_observations):
    """List of transformed observations suitable for rendering in HTML with a Jinja2 template."""
    result = []
    for o in artportalen_observations["records"]:
        # Establish what name of the taxon to use
        if "vernacularName" in o.get("taxon", {}):
            name = o["taxon"]["vernacularName"].capitalize()
        else:
            name = o["taxon"]["scientificName"]
        info = {"name": name}

        # Fix a compact representation of the time of the observation
        d = dtime.fromisoformat(o["event"]["startDate"])
        starttime = d.astimezone().strftime("%H:%M")
        d = dtime.fromisoformat(o["event"]["endDate"])
        endtime = d.astimezone().strftime("%H:%M")
        if starttime == "00:00" and endtime == "23:59":
            t = ""
        elif starttime == endtime:
            t = starttime
        else:
            t = f"{starttime}-{endtime}"
        info["time"] = t

        # Establish observers or data source
        if "recordedBy" in o.get("occurrence", {}):
            observers = o["occurrence"]["recordedBy"]
        else:
            observers = o["datasetName"]
        info["observers"] = observers

        # Establish longitude and latitude
        info["longitude"] = o["location"]["decimalLongitude"]
        info["latitude"] = o["location"]["decimalLatitude"]

        # Establish dataset name, eg. "Artportalen", "iNaturalist" etc.
        info["data_source"] = o["datasetName"]

        # Establish id in data set
        info["id"] = o["occurrence"]["occurrenceId"]

        # Get additional data on the observation from Artportalen
        if o["datasetName"] == "Artportalen":
            obs = oapi.observation_by_id(info["id"], "Extended")
            if not obs:
                extra = {"info": "Failed to get data on individual observation",
                         "id": f"{info['id']}"}
                logger.warning("Call to main.transformed_observations()",
                               extra=extra)
            else:
                info["occurrence"] = obs["occurrence"]
                locality = obs["location"]["locality"]
                is_redlisted = obs["taxon"]["attributes"]["isRedlisted"]
                if is_redlisted:
                    redlist_category = obs["taxon"]["attributes"]["redlistCategory"]
                else:
                    redlist_category = None

                # Set redlist info
                info["isRedlisted"] = is_redlisted
                info["redlistCategory"] = redlist_category

                # Set number of indviduals, sex, age and activity
                info["number"] = obs["occurrence"]["organismQuantity"]
                if "sex" in obs["occurrence"]:
                    sex = obs["occurrence"]["sex"]["id"]
                    if not artportalen.vocabulary_sex[sex]["symbol"]:
                        info["sex"] = sex
                    else:
                        info["sex"] = artportalen.vocabulary_sex[sex]["symbol"]
                else:
                    info["sex"] = None
                if "lifeStage" in obs["occurrence"]:
                    info["age"] = obs["occurrence"]["lifeStage"]["value"]
                else:
                    info["age"] = None
                if "activity" in obs["occurrence"]:
                    info["activity"] = obs["occurrence"]["activity"]["value"]
                else:
                    info["activity"] = None
                info["taxa_summary"] = summarized_taxa_info(info["name"],
                                                            is_redlisted=is_redlisted,
                                                            redlist_category=redlist_category,
                                                            number=info["number"],
                                                            age=info["age"],
                                                            sex=info["sex"],
                                                            activity=info["activity"])

                # Set locality info
                info["locality"] = locality
                info["longitude"] = None
                info["latitude"] = None

                # Set URL to observation info at source
                info["data_source_observation_url"] = obs["occurrence"]["url"]

        elif o["datasetName"] == "iNaturalist":
            # Set number of indviduals, sex, age and activity
            info["number"] = None
            info["sex"] = None
            info["age"] = None
            info["activity"] = None
            # There's no info in these records about redlisting, sof or now we just ignore it
            info["taxa_summary"] = summarized_taxa_info(info["name"],
                                                        is_redlisted=False,
                                                        redlist_category=None,
                                                        number=info["number"],
                                                        age=info["age"],
                                                        sex=info["sex"],
                                                        activity=info["activity"])

            # Set locality info
            municipality = o['location']['municipality']['name']
            county = o['location']['county']['name']
            info["locality"] = f"{municipality}, {county}"

            # Set URL to observation info at source
            info["data_source_observation_url"] = o["occurrence"]["occurrenceId"]

        elif o["datasetName"] == "Bird ringing centre in Sweden, via GBIF":
            obs = oapi.observation_by_id(info["id"], "Extended")

            # No info on observers
            info["observers"] = ""

            # Set redlist info
            info["isRedlisted"] = is_redlisted
            info["redlistCategory"] = redlist_category

            # Set number of indviduals, sex, age and activity
            info["number"] = obs["occurrence"]["individualCount"]
            info["sex"] = None
            info["age"] = None
            info["activity"] = None
            info["taxa_summary"] = summarized_taxa_info(info["name"],
                                                        is_redlisted=is_redlisted,
                                                        redlist_category=redlist_category,
                                                        number=info["number"],
                                                        age=info["age"],
                                                        sex=info["sex"],
                                                        activity=info["activity"])

            # Set locality info
            municipality = o['location']['municipality']['name']
            county = o['location']['county']['name']
            info["locality"] = f"{municipality}, {county}"

            # Set URL to observation info at source. The Jinja2 template will only create links
            # if info["id"] begins with "http".
            info["data_source_observation_url"] = info["id"]

        # Add the rarity level according to some model not yet decided!
        # TBD
#        if info["name"] == "Ringnäbbad mås":
#            info["rarity"] = 10
#        else:
#            info["rarity"] = 1

        result.append(info)
    return result


def observations_for_presentation(observations_date):
    """Dictionary with observations for the given `observations_date` (in "YYYY--MM-DD" format) and
       all attribute values needed for the Jinja2 template file
       "index-page-observations-section.html" to render HTML."""
    previous_date = (observations_date - timedelta(days=1)).isoformat()
    next_date = (observations_date + timedelta(days=1)).isoformat()

    # Get obeservations from the Artportalen API
    observations = get_observations(observations_date.isoformat(),
                                    observations_date.isoformat(),
                                    None,
                                    None)
    # Transform the observations to representations suitable for Jinja2
    observations = transformed_observations(observations)
    return {"day": observations_date.strftime('%A, %-d %B').capitalize(),
            "is_today": observations_date == dt.today(),
            "year": observations_date.year,
            "previous_date": previous_date,
            "date": observations_date.isoformat(),
            "next_date": next_date,
            "observations": observations}


# Set up FastAPI
app = FastAPI(
    title="Microbirding SthlmBetong",
    version=settings.VERSION)
app.mount("/resources", StaticFiles(directory="resources"), name="resources")


# The application resources
@app.get("/", response_class=HTMLResponse)
def get_index_file(request: Request, date: str = Query(None), index_page: str = Query(None)):
    """The main application page (index.html) with observations for the given `date`. The
       `index_page` query parameter is a development for easily chosing which Jinja2 template
       to use as the index_page."""
    tic = time.perf_counter_ns()

    # TBD: Redirect to this page removing unrecognized query parameters or simply remove them by
    # pushing a path that only contains the valid query parameters.

    if not date:
        today = dt.today().isoformat()
        url = request.url.include_query_params(date=today)
        return RedirectResponse(str(url), status_code=status.HTTP_307_TEMPORARY_REDIRECT)

    if not index_page:
        index_page = "index.html"

    # Figure out which date to get observations for
    if date:
        try:
            observations_date = dt.fromisoformat(date)
            if observations_date > dt.today():
                return RedirectResponse(url="/", status_code=status.HTTP_302_FOUND)
        except ValueError:
            # Redirect to root without query parameters
            return RedirectResponse(url="/", status_code=status.HTTP_302_FOUND)
    else:
        observations_date = dt.today()

    obs = observations_for_presentation(observations_date)
    result = templates.TemplateResponse(index_page,
                                        {"request": request,
                                         "day": obs["day"],
                                         "year": observations_date.year,
                                         "is_today": obs["is_today"],
                                         "previous_date": obs["previous_date"],
                                         "date": obs["date"],
                                         "next_date": obs["next_date"],
                                         "observations": obs["observations"],
                                         "release": release_tag(),
                                         "build_datetime": build_datetime_tag()})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


# The application hypermedia control resources.
# All of these resources have the prefix "/hx/" in their URL path.

@app.get("/hx/observations-section", response_class=HTMLResponse)
def hx_observations_section(request: Request, date: str = Query(None)):
    """The observations HTML <section> element with the observations for the given `date`."""
    # We assume we have a valid date that isn't ahead of today's date.
    observations_date = dt.fromisoformat(date)
    obs = observations_for_presentation(observations_date)
    return templates.TemplateResponse("index-page-observations-section.html",
                                      {"request": request,
                                       "day": obs["day"],
                                       "year": observations_date.year,
                                       "is_today": obs["is_today"],
                                       "previous_date": obs["previous_date"],
                                       "date": obs["date"],
                                       "next_date": obs["next_date"],
                                       "observations": obs["observations"]})
