#!/usr/bin/env python

"""This is the SthlmBetong web app."""

# FastAPI and Pydantic
from fastapi import FastAPI, status, Request, Query
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from pydantic_settings import BaseSettings
# Basic Python modules
from typing import Optional
import sys
import os.path
import locale
import json
import logging
import logging.config
import time
from datetime import date as dt, timedelta
from datetime import datetime as dtime
# Application modules
import artportalen


# Constants
secrets = ["ARTPORTALEN_OBSERVATIONS_API_KEY",
           "ARTPORTALEN_SPECIES_API_KEY"]
# We read the local RELEASE_TAG_FILE and a BUILD_DATETIME_TAG that should be generated by the CI/CD
# build script(s).
RELEASE_TAG_FILE = "./RELEASE_TAG_FILE"
BUILD_DATETIME_FILE = "./BUILD_DATETIME_FILE"


def release_tag():
    """Return the release tag."""
    if os.path.exists(RELEASE_TAG_FILE):
        with open(RELEASE_TAG_FILE) as f:
            return f.read().strip()
    else:
        return "No RELEASE_TAG_FILE found"


def build_datetime_tag():
    """Return the build datetime tag."""
    if os.path.exists(BUILD_DATETIME_FILE):
        with open(BUILD_DATETIME_FILE) as f:
            return f.read().strip()
    else:
        return "No BUILD_DATETIME_FILE found"


def file_secret_as_env(var_name: str):
    """Reads a secret from a textfile - if that file exists - and then ads the secret to the
       "environment" of this program. This is used to enable this program to read secrets from
       textfiles when it is packaged as a Docker image and run as a Docker container."""
    # The convention for Docker compose files is to name these files *_FILE and provide that name
    # and its value - a file path - as an environment variable.
    file_var = f"{var_name}_FILE"
    if file_path := os.getenv(file_var):
        with open(file_path) as f:
            value = f.read().strip()
            os.environ[var_name] = value


# Read in the secrets from files, if they exist, as environment variables. They will then be picked
# up by Settings below.
[file_secret_as_env(var) for var in secrets]


class Settings(BaseSettings):
    """Provides configuration and environment variables via the Pydantic BaseSettings class. Values
       are read in this order:
       1) Environment variables. If they are not set then from
       2) Key/values from a ".env" file. If they are not set there then from
       3) Default values set in this class."""
    VERSION: str = "0.0.1"
    TEMPLATES_DIR: str = "templates"
    DATE_FORMAT: str = "Date: %a, %d %b %Y %H:%M:%S"
    ARTPORTALEN_OBSERVATIONS_API_KEY: Optional[str] = None
    ARTPORTALEN_SPECIES_API_KEY: Optional[str] = None
    POLYGON_FILE: str = "./conf/polygon.sthlmbetong.json"
    DEFAULT_TAXON_SEARCH_ID: int = 4000104  # Id of the taxon "Aves" in the Artportalen Species API.
    DEFAULT_NUMBER_OF_OBSERVATIONS: int = 50
    LOGGING_LEVEL: str = "DEBUG"
    logger: logging.Logger = logging.getLogger(__name__)
    logger.setLevel(LOGGING_LEVEL)

    class ConfigDict:
        env_file = ".env"


def polygon_coordinates(filename):
    """The list of polygon coordinates in WGS84 from the file `filename` to use when searching
       for observations in the Artportalen Observations API. Return None if it fails."""
    result = None
    if not os.path.exists(filename):
        settings.logger.error(f"Polygon file {filename} not found.")
    else:
        with open(filename) as f:
            try:
                result = json.load(f)
            except json.decoder.JSONDecodeError:
                settings.logger.error(f"Polygon file {filename} is not a valid JSON file.")
    return result


# Set up some application globals
settings = Settings()
if not settings.ARTPORTALEN_OBSERVATIONS_API_KEY:
    settings.logger.error("Environment variable 'ARTPORTALEN_OBSERVATIONS_API_KEY' not set")
    sys.exit(1)
if not settings.ARTPORTALEN_SPECIES_API_KEY:
    settings.logger.error("Environment variable 'ARTPORTALEN_SPECIES_API_KEY' not set")
    sys.exit(2)
if not settings.POLYGON_FILE:
    settings.logger.error("Environment variable 'POLYGON_FILE' not set")
    sys.exit(3)
templates = Jinja2Templates(directory=settings.TEMPLATES_DIR)
sapi = artportalen.SpeciesAPI(settings.ARTPORTALEN_SPECIES_API_KEY)
oapi = artportalen.ObservationsAPI(settings.ARTPORTALEN_OBSERVATIONS_API_KEY)
polygon = polygon_coordinates(settings.POLYGON_FILE)
if not polygon:
    settings.logger.error(f"Failed to read polygon coordinates from {settings.POLYGON_FILE}.")
locale.setlocale(locale.LC_TIME, 'sv_SE.UTF-8')


def get_observations(from_date, to_date, taxon_name=None, observer_name=None):
    """Get observations from the Artportalen API, make them tidy and consumable by the Jinja2
       templates and put them into a list."""
    # Get the taxa ids that match the given `taxon_name`.
    taxon_ids = [settings.DEFAULT_TAXON_SEARCH_ID]
    if taxon_name:
        taxa = sapi.taxa_by_name(taxon_name,
                                 exact_match=True)
        if not taxa:
            settings.debug(f"No taxa matching {taxon_name} found in Artportalen Species API")
        else:
            taxon_ids = [t["taxonId"] for t in taxa]

    # Set up the search filter for the Artportalen Observations API
    sfilter = artportalen.SearchFilter()
    sfilter.set_taxon(ids=taxon_ids)
    sfilter.set_geographics_geometries(geometries=[{"type": "polygon",
                                                    "coordinates": [polygon]}])
    sfilter.set_verification_status()
    sfilter.set_output()
    sfilter.set_date(startDate=from_date,
                     endDate=to_date,
                     dateFilterType="OverlappingStartDateAndEndDate",
                     timeRanges=[])
    sfilter.set_modified_date()
    sfilter.set_dataProvider()
    observations = oapi.observations(sfilter,
                                     skip=0,
                                     take=1000,
                                     sort_descending=True,
                                     verbose=False)
    return observations


def transformed_observations(artportalen_observations):
    """List of transformed observations suitable for rendering in HTML with a Jinja2 template."""
    result = []
    for o in artportalen_observations["records"]:
        # Fix a compact representation of the time of the observation
        d = dtime.fromisoformat(o["event"]["startDate"])
        starttime = d.astimezone().strftime("%H:%M")
        d = dtime.fromisoformat(o["event"]["endDate"])
        endtime = d.astimezone().strftime("%H:%M")
        if starttime == "00:00" and endtime == "23:59":
            t = ""
        elif starttime == endtime:
            t = starttime
        else:
            t = f"{starttime}-{endtime}"
        # Establish observers or data source
        if "recordedBy" in o.get("occurrence", {}):
            observers = o["occurrence"]["recordedBy"]
        else:
            observers = o["datasetName"]
        # Establish what name of the taxon to use
        if "vernacularName" in o.get("taxon", {}):
            name = o["taxon"]["vernacularName"].capitalize()
        else:
            name = o["taxon"]["scientificName"]
        x = {"name": name,
             "location": o["location"],
             "time": t,
             "observers": observers}
        # Add the rarity level
        if x["name"] == "Ringnäbbad mås":
            x["rarity"] = 10
        else:
            x["rarity"] = 1
        result.append(x)
    return result


def observations_for_presentation(observations_date):
    """Dictionary with observations for the given `observations_date` (in "YYYY--MM-DD" format) and
       all attribute values needed for the Jinja2 template file
       "index-page-observations-section.html" to render HTML."""
    previous_date = (observations_date - timedelta(days=1)).isoformat()
    next_date = (observations_date + timedelta(days=1)).isoformat()

    # Get obeservations from the Artportalen API
    observations = get_observations(observations_date.isoformat(),
                                    observations_date.isoformat(),
                                    None,
                                    None)
    # Transform the observations to representations suitable for Jinja2
    observations = transformed_observations(observations)
    return {"day": observations_date.strftime('%A, %-d %B').capitalize(),
            "is_today": observations_date == dt.today(),
            "year": observations_date.year,
            "previous_date": previous_date,
            "date": observations_date.isoformat(),
            "next_date": next_date,
            "observations": observations}


# Set up FastAPI
app = FastAPI(
    title="Microbirding SthlmBetong",
    version=settings.VERSION)
app.mount("/resources", StaticFiles(directory="resources"), name="resources")


# The application resources
@app.get("/", response_class=HTMLResponse)
async def get_index_file(request: Request, date: str = Query(None), index_page: str = Query(None)):
    """The main application page (index.html) with observations for the given `date`. The
       `index_page` query parameter is a development for easily chosing which Jinja2 template
       to use as the index_page."""
    tic = time.perf_counter_ns()

    # TBD: Redirect to this page removing unrecognized query parameters or simply remove them by
    # pushing a path that only contains the valid query parameters.

    if not date:
        today = dt.today().isoformat()
        url = request.url.include_query_params(date=today)
        return RedirectResponse(str(url), status_code=status.HTTP_307_TEMPORARY_REDIRECT)

    if not index_page:
        index_page = "index.html"

    # Figure out which date to get observations for
    if date:
        try:
            observations_date = dt.fromisoformat(date)
            if observations_date > dt.today():
                return RedirectResponse(url="/", status_code=status.HTTP_302_FOUND)
        except ValueError:
            # Redirect to root without query parameters
            return RedirectResponse(url="/", status_code=status.HTTP_302_FOUND)
    else:
        observations_date = dt.today()

    obs = observations_for_presentation(observations_date)
    result = templates.TemplateResponse(index_page,
                                        {"request": request,
                                         "day": obs["day"],
                                         "is_today": obs["is_today"],
                                         "previous_date": obs["previous_date"],
                                         "date": obs["date"],
                                         "next_date": obs["next_date"],
                                         "observations": obs["observations"],
                                         "release": release_tag(),
                                         "build_datetime": build_datetime_tag()})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


# The application hypermedia control resources.
# All of these resources have the prefix "/hx/" in their URL path.

@app.get("/hx/observations-section", response_class=HTMLResponse)
async def hx_observations_section(request: Request, date: str = Query(None)):
    """The observations HTML <section> element with the observations for the given `date`."""
    # We assume we have a valid date that isn't ahead of today's date.
    observations_date = dt.fromisoformat(date)
    obs = observations_for_presentation(observations_date)
    return templates.TemplateResponse("index-page-observations-section.html",
                                      {"request": request,
                                       "day": obs["day"],
                                       "is_today": obs["is_today"],
                                       "previous_date": obs["previous_date"],
                                       "date": obs["date"],
                                       "next_date": obs["next_date"],
                                       "observations": obs["observations"]})
