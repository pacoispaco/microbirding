#!/usr/bin/env python

"""This is the SthlmBetong web app."""

# FastAPI and Pydantic
from fastapi import FastAPI, status, Request, Query, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from pydantic_settings import BaseSettings
from requests.exceptions import HTTPError
# Basic Python modules
from typing import Optional
import sys
import os.path
import locale
import json
import atexit
import logging
import logging.config
import time
from datetime import date as dt, timedelta
from datetime import datetime as dtime
# Application modules
import artportalen
import mapping
from mistune_tasklist_renderer import mistune_markdown_instance

# Constants
secrets = ["ARTPORTALEN_OBSERVATIONS_API_KEY",
           "ARTPORTALEN_SPECIES_API_KEY"]
# We read the local RELEASE_TAG_FILE and a BUILD_DATETIME_TAG that should be generated by the CI/CD
# build script(s).
RELEASE_TAG_FILE = "./RELEASE_TAG_FILE"
BUILD_DATETIME_FILE = "./BUILD_DATETIME_FILE"
GIT_HASH_FILE = "./GIT_HASH_FILE"

logger = logging.getLogger(__name__)


def get_handler_by_name(name: str):
    """This can be removed in Python 3.12 since there we have logging.getHandlerByName."""
    for logger_name in logging.root.manager.loggerDict:
        logger = logging.getLogger(logger_name)
        for handler in logger.handlers:
            if handler.name == name:
                return handler
    # also check root logger
    for handler in logging.getLogger().handlers:
        if handler.name == name:
            return handler
    return None


def setup_logging(config_filepath):
    """Set up logging. If no logging config file is found, set up default logging."""
    if os.path.exists(config_filepath):
        with open(config_filepath) as f:
            config = json.load(f)
        logging.config.dictConfig(config)
        queue_handler = get_handler_by_name("queue_handler")
        if queue_handler is not None:
            queue_handler.listener.start()
            atexit.register(queue_handler.listener.stop)
    else:
        logger.setLevel("DEBUG")
        logger.warning(f"Configuration file '{config_filepath}' for logging not found. "
                       "Using default logging settings.")


def release_tag():
    """Return the release tag."""
    if os.path.exists(RELEASE_TAG_FILE):
        with open(RELEASE_TAG_FILE) as f:
            return f.read().strip()
    else:
        return "No RELEASE_TAG_FILE found"


def build_datetime_tag():
    """Return the build datetime tag."""
    if os.path.exists(BUILD_DATETIME_FILE):
        with open(BUILD_DATETIME_FILE) as f:
            return f.read().strip()
    else:
        return "No BUILD_DATETIME_FILE found"


def git_hash_tag():
    """Return the git hash tag of the git commit used to build this Docker image."""
    if os.path.exists(GIT_HASH_FILE):
        with open(GIT_HASH_FILE) as f:
            return f.read().strip()
    else:
        return "No GIT_HASH_FILE found"


def file_secret_as_env(var_name: str):
    """Reads a secret from a textfile - if that file exists - and then ads the secret to the
       "environment" of this program. This is used to enable this program to read secrets from
       textfiles when it is packaged as a Docker image and run as a Docker container."""
    # The convention for Docker compose files is to name these files *_FILE and provide that name
    # and its value - a file path - as an environment variable.
    file_var = f"{var_name}_FILE"
    if file_path := os.getenv(file_var):
        with open(file_path) as f:
            value = f.read().strip()
            os.environ[var_name] = value


# Read in the secrets from files, if they exist, as environment variables. They will then be picked
# up by Settings below.
[file_secret_as_env(var) for var in secrets]


class Settings(BaseSettings):
    """Provides configuration and environment variables via the Pydantic BaseSettings class. Values
       are read in this order:
       1) Environment variables. If they are not set then from
       2) Key/values from a ".env" file. If they are not set there then from
       3) Default values set in this class."""
    VERSION: str = "0.0.1"
    TEMPLATES_DIR: str = "templates"
    DATE_FORMAT: str = "Date: %a, %d %b %Y %H:%M:%S"
    ARTPORTALEN_OBSERVATIONS_API_KEY: Optional[str] = None
    ARTPORTALEN_SPECIES_API_KEY: Optional[str] = None
    MICROBIRDING_AREA_DIRECTORY: str = "./data/areas"
    DEFAULT_TAXON_SEARCH_ID: int = 4000104  # Id of the taxon "Aves" in the Artportalen Species API.
    DEFAULT_NUMBER_OF_OBSERVATIONS: int = 50
    LOGGING_CONFIG_FILE: str = "./conf/logging-config.json"
    ABOUT_CONTENT_DIRECTORY: str = "./content"
    ABOUT_SECTIONS: dict[str, str] = {
        "about-app": "about-app.md",
        "personal-data-policy": "personal-data-policy.md",
        "terms-of-use": "terms-of-use.md",
        "team": "team.md",
    }
    ABOUT_DEFAULT_SLUG: str = "about-app"

    class ConfigDict:
        env_file = ".env"


# Set up some application globals
settings = Settings()
setup_logging(settings.LOGGING_CONFIG_FILE)
if not settings.ARTPORTALEN_OBSERVATIONS_API_KEY:
    settings.logger.error("Environment variable 'ARTPORTALEN_OBSERVATIONS_API_KEY' not set")
    sys.exit(1)
if not settings.ARTPORTALEN_SPECIES_API_KEY:
    settings.logger.error("Environment variable 'ARTPORTALEN_SPECIES_API_KEY' not set")
    sys.exit(2)
if not settings.MICROBIRDING_AREA_DIRECTORY:
    settings.logger.error("Environment variable 'MICROBIRDING_AREA_DIRECTORY' not set")
    sys.exit(3)
templates = Jinja2Templates(directory=settings.TEMPLATES_DIR)
sapi = artportalen.SpeciesAPI(settings.ARTPORTALEN_SPECIES_API_KEY)
oapi = artportalen.ObservationsAPI(settings.ARTPORTALEN_OBSERVATIONS_API_KEY)
mapping.configure(settings.MICROBIRDING_AREA_DIRECTORY)
locale.setlocale(locale.LC_TIME, 'sv_SE.UTF-8')
logger.info("Application initialized.")


def get_observations(area_name, from_date, to_date, taxon_name=None, observer_name=None):
    """Get observations from the Artportalen API, make them tidy and consumable by the Jinja2
       templates and put them into a list."""
    # Get the taxa ids that match the given `taxon_name`.
    taxon_ids = [settings.DEFAULT_TAXON_SEARCH_ID]
    if taxon_name:
        taxa = sapi.taxa_by_name(taxon_name,
                                 exact_match=True)
        if not taxa:
            settings.debug(f"No taxa matching {taxon_name} found in Artportalen Species API")
        else:
            taxon_ids = [t["taxonId"] for t in taxa]

    # Set up the search filter for the Artportalen Observations API
    sfilter = artportalen.SearchFilter()
    sfilter.set_taxon(ids=taxon_ids)

    area = mapping.area_by_name(area_name)
    polygon = area.geopolygons[0].serialize_as_list()
    sfilter.set_geographics_geometries(geometries=[{"type": "polygon",
                                                    "coordinates": [polygon]}])
    sfilter.set_verification_status()
    sfilter.set_output(fieldSet="Extended")
    sfilter.set_date(startDate=from_date,
                     endDate=to_date,
                     dateFilterType="OverlappingStartDateAndEndDate",
                     timeRanges=[])
    sfilter.set_modified_date()
    sfilter.set_dataProvider()
    try:
        observations = oapi.observations(sfilter,
                                         skip=0,
                                         take=1000,
                                         sort_descending=True)
    except HTTPError as e:
        logger.warning("HTTPError in artportalen.observations()",
                       extra={"exception": e})
        return None

    return observations


def summarized_taxa_info(is_redlisted=False,
                         redlist_category=None,
                         sex=None,
                         number=None,
                         age=None,
                         activity=None):
    """Formatted string with taxa info on observation, for Jinja2 to use in UI presentation.
       Eg. 'Östersjötrut, 1 födosökande'."""
    result = ""
    if number or sex or age or activity:
        result += ","
    if number:
        result += f" {number}"
    if age:
        result += f" {age}"
    if sex:
        result += f" {sex}"
    if activity:
        result += f" {activity}"
    if is_redlisted:
        result += f" ({redlist_category})"
    return result.strip(",")


def transformed_observations(artportalen_observations):
    """List of transformed observations suitable for rendering in HTML with a Jinja2 template.
       Here we can add rarity data and other stuff which affects how observations is presented."""
    result = []
    for o in artportalen_observations["records"]:
        # Establish what name of the taxon to use
        if "vernacularName" in o.get("taxon", {}):
            name = o["taxon"]["vernacularName"].capitalize()
        else:
            name = o["taxon"]["scientificName"]
        info = {"name": name}

        # Fix a compact representation of the time of the observation
        d = dtime.fromisoformat(o["event"]["startDate"])
        starttime = d.astimezone().strftime("%H:%M")
        d = dtime.fromisoformat(o["event"]["endDate"])
        endtime = d.astimezone().strftime("%H:%M")
        if starttime == "00:00" and endtime == "23:59":
            t = ""
        elif starttime == endtime:
            t = starttime
        else:
            t = f"{starttime}-{endtime}"
        info["time"] = t

        # Establish observers or data source
        if "recordedBy" in o.get("occurrence", {}):
            observers = o["occurrence"]["recordedBy"]
        else:
            observers = o["datasetName"]
        info["observers"] = observers

        # Establish longitude and latitude
        info["longitude"] = o["location"]["decimalLongitude"]
        info["latitude"] = o["location"]["decimalLatitude"]

        # Establish dataset name, eg. "Artportalen", "iNaturalist" etc.
        info["data_source"] = o["datasetName"]
        if info["data_source"] == "Artportalen":
            info["data_source_abbreviation"] = "AP"
        elif info["data_source"] == "iNaturalist":
            info["data_source_abbreviation"] = "IN"
        elif info["data_source"] == "Bird ringing centre in Sweden, via GBIF":
            info["data_source_abbreviation"] = "BR"
        else:
            info["data_source_abbreviation"] = info["data_source"]

        # Establish id in data set
        info["id"] = o["occurrence"]["occurrenceId"]

        # Get additional data on the observation from Artportalen
        if o["datasetName"] == "Artportalen":
            info["occurrence"] = o["occurrence"]
            locality = o["location"]["locality"].split(",")[0]
            is_redlisted = o["taxon"]["attributes"]["isRedlisted"]
            if is_redlisted:
                redlist_category = o["taxon"]["attributes"]["redlistCategory"]
            else:
                redlist_category = None

            # Set redlist info
            info["isRedlisted"] = is_redlisted
            info["redlistCategory"] = redlist_category

            # Set number of individuals, sex, age and activity
            info["number"] = o["occurrence"]["organismQuantity"]
            if "sex" in o["occurrence"]:
                sex = o["occurrence"]["sex"]["id"]
                if not artportalen.vocabulary_sex[sex]["symbol"]:
                    info["sex"] = sex
                else:
                    info["sex"] = artportalen.vocabulary_sex[sex]["symbol"]
            else:
                info["sex"] = None
            if "lifeStage" in o["occurrence"]:
                info["age"] = o["occurrence"]["lifeStage"]["value"]
            else:
                info["age"] = None
            if "activity" in o["occurrence"]:
                info["activity"] = o["occurrence"]["activity"]["value"]
            else:
                info["activity"] = None
            info["taxa_summary"] = summarized_taxa_info(is_redlisted=is_redlisted,
                                                        redlist_category=redlist_category,
                                                        number=info["number"],
                                                        age=info["age"],
                                                        sex=info["sex"],
                                                        activity=info["activity"])

            # Set locality info
            info["locality"] = locality
            info["longitude"] = None
            info["latitude"] = None

            # Set URL to observation info at source
            info["data_source_observation_url"] = o["occurrence"]["url"]

        elif o["datasetName"] == "iNaturalist":
            # Set number of indviduals, sex, age and activity
            info["number"] = None
            info["sex"] = None
            info["age"] = None
            info["activity"] = None
            # There's no info in these records about redlisting, sof or now we just ignore it
            info["taxa_summary"] = summarized_taxa_info(is_redlisted=False,
                                                        redlist_category=None,
                                                        number=info["number"],
                                                        age=info["age"],
                                                        sex=info["sex"],
                                                        activity=info["activity"])

            # Set locality info
            municipality = o['location']['municipality']['name']
            county = o['location']['county']['name']
            info["locality"] = f"{municipality}, {county}"

            # Set URL to observation info at source
            info["data_source_observation_url"] = o["occurrence"]["occurrenceId"]

        elif o["datasetName"] == "Bird ringing centre in Sweden, via GBIF":
            # No info on observers
            info["observers"] = ""

            # Set redlist info
            info["isRedlisted"] = is_redlisted
            info["redlistCategory"] = redlist_category

            # Set number of indviduals, sex, age and activity
            info["number"] = o["occurrence"]["individualCount"]
            info["sex"] = None
            info["age"] = None
            info["activity"] = None
            info["taxa_summary"] = summarized_taxa_info(is_redlisted=is_redlisted,
                                                        redlist_category=redlist_category,
                                                        number=info["number"],
                                                        age=info["age"],
                                                        sex=info["sex"],
                                                        activity=info["activity"])

            # Set locality info
            municipality = o['location']['municipality']['name']
            county = o['location']['county']['name']
            info["locality"] = f"{municipality}, {county}"

            # Set URL to observation info at source. The Jinja2 template will only create links
            # if info["id"] begins with "http".
            info["data_source_observation_url"] = info["id"]

        # Add the rarity level according to some model not yet decided!
        # TBD
#        if info["name"] == "Ringnäbbad mås":
#            info["rarity"] = 10
#        else:
#            info["rarity"] = 1

        result.append(info)
    return result


def observations_for_presentation(area_name: str, observations_date):
    """Dictionary with observations for the given `observations_date` (in "YYYY--MM-DD" format) and
       all attribute values needed for the Jinja2 template file
       "hx-observations-list.html" to render HTML."""
    previous_date = (observations_date - timedelta(days=1)).isoformat()
    next_date = (observations_date + timedelta(days=1)).isoformat()

    # Get obeservations from the Artportalen API
    observations = get_observations(area_name,
                                    observations_date.isoformat(),
                                    observations_date.isoformat(),
                                    None,
                                    None)
    if not observations:
        extra = {"info": "Failed to get data on observations for a given date",
                 "date": f"{observations_date.isoformat()}"}
        logger.warning("Call to main.observations_for_presentation()",
                       extra=extra)
        observations = ["Failed"]
    else:
        # Transform the observations to representations suitable for Jinja2
        observations = transformed_observations(observations)
    return {"day": observations_date.strftime('%A, %-d/%-m').capitalize(),
            "is_today": observations_date == dt.today(),
            "year": observations_date.year,
            "previous_date": previous_date,
            "date": observations_date.isoformat(),
            "next_date": next_date,
            "observations": observations}


# Set up FastAPI
app = FastAPI(
    title="Microbirding webapp",
    version=settings.VERSION)
app.mount("/resources", StaticFiles(directory="resources"), name="resources")


# The application resources
@app.get("/", response_class=HTMLResponse)
def get_index_file(request: Request, date: str = Query(None), index_page: str = Query(None)):
    """The main application page (page-observations.html) with observations for the given `date`.
        The `index_page` query parameter is a development for easily chosing which Jinja2 template
       to use as the index_page."""
    tic = time.perf_counter_ns()

    # TBD: Redirect to this page removing unrecognized query parameters or simply remove them by
    # pushing a path that only contains the valid query parameters.

    if not date:
        today = dt.today().isoformat()
        url = request.url.include_query_params(date=today)
        return RedirectResponse(str(url), status_code=status.HTTP_307_TEMPORARY_REDIRECT)

    if not index_page:
        index_page = "page-observations.html"

    # Figure out which date to get observations for
    if date:
        try:
            observations_date = dt.fromisoformat(date)
            if observations_date > dt.today():
                return RedirectResponse(url="/", status_code=status.HTTP_302_FOUND)
        except ValueError:
            # Redirect to root without query parameters
            return RedirectResponse(url="/", status_code=status.HTTP_302_FOUND)
    else:
        observations_date = dt.today()

    area_name = "SthlmBetong"
    obs = observations_for_presentation(area_name, observations_date)
    result = templates.TemplateResponse(index_page,
                                        {"request": request,
                                         "day": obs["day"],
                                         "year": observations_date.year,
                                         "is_today": obs["is_today"],
                                         "previous_date": obs["previous_date"],
                                         "date": obs["date"],
                                         "next_date": obs["next_date"],
                                         "observations": obs["observations"],
                                         "version_info": {"release": release_tag(),
                                                          "built": build_datetime_tag(),
                                                          "git_hash": git_hash_tag()}})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


@app.get("/changelog", response_class=HTMLResponse)
def get_changelog(request: Request):
    """The changelog page page (page-changelog.html) displaying the version and changelog history
       of the app."""
    tic = time.perf_counter_ns()

    markdown = mistune_markdown_instance(disabled=True)

    with open("./CHANGELOG.md") as f:
        html = markdown(f.read())
    result = templates.TemplateResponse("page-changelog.html",
                                        {"request": request,
                                         "changelog_html": html,
                                         "version_info": {"release": release_tag(),
                                                          "built": build_datetime_tag(),
                                                          "git_hash": git_hash_tag()}})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


@app.get("/maps", response_class=HTMLResponse)
def get_maps(request: Request):
    """The maps page (page-maps.html) displaying the map of SthlmBetong."""
    tic = time.perf_counter_ns()

    result = templates.TemplateResponse("page-maps.html",
                                        {"request": request,
                                         "version_info": {"release": release_tag(),
                                                          "built": build_datetime_tag(),
                                                          "git_hash": git_hash_tag()}})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


@app.get("/about", response_class=HTMLResponse)
async def about_root():
    """The root resource for the about pages. Redirects to the default about page."""
    return RedirectResponse(
        url=f"/about/{settings.ABOUT_DEFAULT_SLUG}",
        status_code=307
    )


@app.get("/about/{slug}", response_class=HTMLResponse)
def get_about(request: Request, slug: str):
    """The about page (page-about.html) with information on the app."""
    tic = time.perf_counter_ns()

    if slug not in settings.ABOUT_SECTIONS:
        raise HTTPException(status_code=404, detail="Unknown section")

    markdown = mistune_markdown_instance(disabled=True)
    md_path = os.path.join(settings.ABOUT_CONTENT_DIRECTORY, settings.ABOUT_SECTIONS[slug])
    if not os.path.exists(md_path):
        raise HTTPException(status_code=500, detail="Missing content file")
    with open(md_path) as f:
        html = markdown(f.read())

    result = templates.TemplateResponse(
        "page-about.html",
        {
            "request": request,
            "active_slug": slug,
            "section_html": html,
            "version_info": {"release": release_tag(),
                             "built": build_datetime_tag(),
                             "git_hash": git_hash_tag()}
        },
    )

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


# The application hypermedia control resources.
# All of these resources have the prefix "/hx/" in their URL path.

@app.get("/hx/observations-section", response_class=HTMLResponse)
def hx_observations_section(request: Request, date: str = Query(None)):
    """The observations HTML <section> element with the observations for the given `date`."""
    # We assume we have a valid date that isn't ahead of today's date.
    observations_date = dt.fromisoformat(date)
    area_name = "SthlmBetong"
    obs = observations_for_presentation(area_name, observations_date)
    return templates.TemplateResponse("hx-observations-list.html",
                                      {"request": request,
                                       "day": obs["day"],
                                       "year": observations_date.year,
                                       "is_today": obs["is_today"],
                                       "previous_date": obs["previous_date"],
                                       "date": obs["date"],
                                       "next_date": obs["next_date"],
                                       "observations": obs["observations"]})


# MapLibre GL JS resources (experimental)

@app.get("/mapping/pins")
def get_mapping_pins():
    """Get some geo pins."""
    return JSONResponse(mapping.models.some_pins())


@app.get("/mapping/areas")
def get_mapping_areas():
    """Get a geo areas."""
    geojson = mapping.geojson_area_by_name("SthlmBetong")
    return JSONResponse(geojson.dict())


@app.get("/mapping/style")
def get_map_style():
    """Get a map style."""
    style = mapping.default_maplibre_style().dict()
    # Set low TTL if data changes often
    return JSONResponse(style, headers={"Cache-Control": "no-cache"})


# The application 404 exception handler

@app.exception_handler(404)
async def not_found(request: Request, exc):
    """Render a 404 page for missing resources."""
    return templates.TemplateResponse(
        "page-404.html",
        {
            "request": request,
            "path": request.url.path,
            "version_info": {
                "release": release_tag(),
                "built": build_datetime_tag(),
                "git_hash": git_hash_tag(),
            },
        },
        status_code=404,
    )
