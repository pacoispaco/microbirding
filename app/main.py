#!/usr/bin/env python

"""This is the SthlmBetong web app."""

# FastAPI and Pydantic
from contextlib import asynccontextmanager
from fastapi import FastAPI, status, Request, Query, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from pydantic_settings import BaseSettings
from requests.exceptions import HTTPError
# Basic Python modules
from typing import Optional
import sys
import os.path
import locale
# import json
# import atexit
import logging
import logging.config
import time
import csv
from datetime import date as dt, timedelta
from datetime import datetime as dtime
# Application modules
import app.artportalen.client as artportalen
import app.mapping as mapping
from app.utils.logging import setup_logging
from app.utils.changelog_renderer import mistune_markdown_instance

# Constants
secrets = ["ARTPORTALEN_OBSERVATIONS_API_KEY",
           "ARTPORTALEN_SPECIES_API_KEY"]
# We read the local RELEASE_TAG_FILE and a BUILD_DATETIME_TAG that should be generated by the CI/CD
# build script(s).
RELEASE_TAG_FILE = "./RELEASE_TAG_FILE"
BUILD_DATETIME_FILE = "./BUILD_DATETIME_FILE"
GIT_HASH_FILE = "./GIT_HASH_FILE"

APP_LOGGER_NAME = "microbirding"
logger = logging.getLogger(APP_LOGGER_NAME)


def release_tag():
    """Return the release tag."""
    if os.path.exists(RELEASE_TAG_FILE):
        with open(RELEASE_TAG_FILE) as f:
            return f.read().strip()
    else:
        return "No RELEASE_TAG_FILE found"


def build_datetime_tag():
    """Return the build datetime tag."""
    if os.path.exists(BUILD_DATETIME_FILE):
        with open(BUILD_DATETIME_FILE) as f:
            return f.read().strip()
    else:
        return "No BUILD_DATETIME_FILE found"


def git_hash_tag():
    """Return the git hash tag of the git commit used to build this Docker image."""
    if os.path.exists(GIT_HASH_FILE):
        with open(GIT_HASH_FILE) as f:
            return f.read().strip()
    else:
        return "No GIT_HASH_FILE found"


def file_secret_as_env(var_name: str):
    """Reads a secret from a textfile - if that file exists - and then ads the secret to the
       "environment" of this program. This is used to enable this program to read secrets from
       textfiles when it is packaged as a Docker image and run as a Docker container."""
    # The convention for Docker compose files is to name these files *_FILE and provide that name
    # and its value - a file path - as an environment variable.
    file_var = f"{var_name}_FILE"
    if file_path := os.getenv(file_var):
        with open(file_path) as f:
            value = f.read().strip()
            os.environ[var_name] = value


# Read in the secrets from files, if they exist, as environment variables. They will then be picked
# up by Settings below.
[file_secret_as_env(var) for var in secrets]


class Settings(BaseSettings):
    """Provides configuration and environment variables via the Pydantic BaseSettings class. Values
       are read in this order:
       1) Environment variables. If they are not set then from
       2) Key/values from a ".env" file. If they are not set there then from
       3) Default values set in this class."""
    VERSION: str = "0.0.1"
    TEMPLATES_DIR: str = "./app/page-templates"
    DATE_FORMAT: str = "Date: %a, %d %b %Y %H:%M:%S"
    ARTPORTALEN_OBSERVATIONS_API_KEY: Optional[str] = None
    ARTPORTALEN_SPECIES_API_KEY: Optional[str] = None
    MICROBIRDING_AREA_DIRECTORY: str = "./data/areas"
    DEFAULT_TAXON_SEARCH_ID: int = 4000104  # Id of the taxon "Aves" in the Artportalen Species API.
    DEFAULT_NUMBER_OF_OBSERVATIONS: int = 50
    LOGGING_CONFIG_FILE: str = "./conf/logging-config.json"
    ABOUT_CONTENT_DIRECTORY: str = "./content"
    ABOUT_SECTIONS: dict[str, str] = {
        "about-app": "about-app.md",
        "personal-data-policy": "personal-data-policy.md",
        "terms-of-use": "terms-of-use.md",
        "team": "team.md",
    }
    ABOUT_DEFAULT_SLUG: str = "about-app"
    ENVIRONMENT: Optional[str] = None
    UMAMI_WEBSITE_ID: Optional[str] = None

    class ConfigDict:
        env_file = ".env"


# Set up some application globals
settings = Settings()
setup_logging(settings.LOGGING_CONFIG_FILE)
if not settings.ARTPORTALEN_OBSERVATIONS_API_KEY:
    settings.logger.error("Environment variable 'ARTPORTALEN_OBSERVATIONS_API_KEY' not set")
    sys.exit(1)
if not settings.ARTPORTALEN_SPECIES_API_KEY:
    settings.logger.error("Environment variable 'ARTPORTALEN_SPECIES_API_KEY' not set")
    sys.exit(2)
if not settings.MICROBIRDING_AREA_DIRECTORY:
    settings.logger.error("Environment variable 'MICROBIRDING_AREA_DIRECTORY' not set")
    sys.exit(3)
templates = Jinja2Templates(directory=settings.TEMPLATES_DIR)
sapi = artportalen.SpeciesAPI(settings.ARTPORTALEN_SPECIES_API_KEY)
oapi = artportalen.ObservationsAPI(settings.ARTPORTALEN_OBSERVATIONS_API_KEY)
mapping.configure(settings.MICROBIRDING_AREA_DIRECTORY)
locale.setlocale(locale.LC_TIME, 'sv_SE.UTF-8')
logger.info("Application initialized.")


def get_observations(area_name, from_date, to_date, taxon_name=None, observer_name=None):
    """Get observations from the Artportalen API, make them tidy and consumable by the Jinja2
       templates and put them into a list."""
    # Get the taxa ids that match the given `taxon_name`.
    taxon_ids = [settings.DEFAULT_TAXON_SEARCH_ID]
    if taxon_name:
        taxa = sapi.taxa_by_name(taxon_name,
                                 exact_match=True)
        if not taxa:
            settings.debug(f"No taxa matching {taxon_name} found in Artportalen Species API")
        else:
            taxon_ids = [t["taxonId"] for t in taxa]

    # Set up the search filter for the Artportalen Observations API
    sfilter = artportalen.SearchFilter()
    sfilter.set_taxon(ids=taxon_ids)

    area = mapping.area_by_name(area_name)
    polygon = area.geopolygons[0].serialize_as_list()
    sfilter.set_geographics_geometries(geometries=[{"type": "polygon",
                                                    "coordinates": [polygon]}])
    sfilter.set_verification_status()
    sfilter.set_output(fieldSet="Extended")
    sfilter.set_date(startDate=from_date,
                     endDate=to_date,
                     dateFilterType="OverlappingStartDateAndEndDate",
                     timeRanges=[])
    sfilter.set_modified_date()
    sfilter.set_dataProvider()
    try:
        observations = oapi.observations(sfilter,
                                         skip=0,
                                         take=1000,
                                         sort_descending=True)
    except HTTPError as e:
        logger.warning("HTTPError in artportalen.observations()",
                       extra={"exception": e})
        return None

    return observations


def transformed_observations(artportalen_observations):
    """List of transformed observations suitable for rendering in HTML with a Jinja2 template.
       Here we can add rarity data and other stuff which affects how observations is presented."""
    result = []
    for o in artportalen_observations["records"]:
        # Establish what name of the taxon to use
        if "vernacularName" in o.get("taxon", {}):
            name = o["taxon"]["vernacularName"].capitalize()
        else:
            name = o["taxon"]["scientificName"]
        info = {"name": name}

        # Fix a compact representation of the time of the observation
        d = dtime.fromisoformat(o["event"]["startDate"])
        starttime = d.astimezone().strftime("%H:%M")
        d = dtime.fromisoformat(o["event"]["endDate"])
        endtime = d.astimezone().strftime("%H:%M")
        if starttime == "00:00" and endtime == "23:59":
            t = ""
        elif starttime == endtime:
            t = starttime
        else:
            t = f"{starttime}-{endtime}"
        info["time"] = t

        # Establish observers or data source
        if "recordedBy" in o.get("occurrence", {}):
            observers = o["occurrence"]["recordedBy"]
        else:
            observers = o["datasetName"]
        info["observers"] = observers

        # Establish longitude and latitude
        info["longitude"] = o["location"]["decimalLongitude"]
        info["latitude"] = o["location"]["decimalLatitude"]

        # Establish dataset name, eg. "Artportalen", "iNaturalist" etc.
        info["data_source"] = o["datasetName"]
        if info["data_source"] == "Artportalen":
            info["data_source_abbreviation"] = "AP"
        elif info["data_source"] == "iNaturalist":
            info["data_source_abbreviation"] = "IN"
        elif info["data_source"] == "Bird ringing centre in Sweden, via GBIF":
            info["data_source_abbreviation"] = "BR"
        else:
            info["data_source_abbreviation"] = info["data_source"]

        # Establish id in data set
        info["id"] = o["occurrence"]["occurrenceId"]

        # Get additional data on the observation from Artportalen
        if o["datasetName"] == "Artportalen":
            info["occurrence"] = o["occurrence"]
            locality = o["location"]["locality"].split(",")[0]
            is_redlisted = o["taxon"]["attributes"]["isRedlisted"]
            if is_redlisted:
                redlist_category = o["taxon"]["attributes"]["redlistCategory"]
            else:
                redlist_category = None

            # Set redlist info
            info["isRedlisted"] = is_redlisted
            info["redlistCategory"] = redlist_category

            # Set number of individuals, sex, age and activity
            info["number"] = o["occurrence"]["organismQuantity"]
            if "sex" in o["occurrence"]:
                sex = o["occurrence"]["sex"]["id"]
                info["sex"] = artportalen.vocabulary_sex[sex]
            else:
                info["sex"] = None
            if "lifeStage" in o["occurrence"]:
                info["age"] = o["occurrence"]["lifeStage"]["value"]
            else:
                info["age"] = None
            if "activity" in o["occurrence"]:
                info["activity"] = o["occurrence"]["activity"]["value"]
            else:
                info["activity"] = None

            # Set locality info
            info["locality"] = locality
            info["longitude"] = None
            info["latitude"] = None

            # Set URL to observation info at source
            info["data_source_observation_url"] = o["occurrence"]["url"]

        elif o["datasetName"] == "iNaturalist":
            # Set number of indviduals, sex, age and activity
            info["number"] = None
            info["sex"] = None
            info["age"] = None
            info["activity"] = None
            # There's no info in these records about redlisting, sof or now we just ignore it

            # Set locality info
            municipality = o['location']['municipality']['name']
            county = o['location']['county']['name']
            info["locality"] = f"{municipality}, {county}"

            # Set URL to observation info at source
            info["data_source_observation_url"] = o["occurrence"]["occurrenceId"]

        elif o["datasetName"] == "Bird ringing centre in Sweden, via GBIF":
            # No info on observers
            info["observers"] = ""

            # Set redlist info
            info["isRedlisted"] = is_redlisted
            info["redlistCategory"] = redlist_category

            # Set number of indviduals, sex, age and activity
            info["number"] = o["occurrence"]["individualCount"]
            info["sex"] = None
            info["age"] = None
            info["activity"] = None

            # Set locality info
            municipality = o['location']['municipality']['name']
            county = o['location']['county']['name']
            info["locality"] = f"{municipality}, {county}"

            # Set URL to observation info at source. The Jinja2 template will only create links
            # if info["id"] begins with "http".
            info["data_source_observation_url"] = info["id"]

        elif o["datasetName"] == "Lund University Biological Museum - Animal Collections":
            info["occurrence"] = o["occurrence"]
            locality = o["location"]["locality"].split(",")[0]
            is_redlisted = o["taxon"]["attributes"]["isRedlisted"]
            if is_redlisted:
                redlist_category = o["taxon"]["attributes"]["redlistCategory"]
            else:
                redlist_category = None

            # Set redlist info
            info["isRedlisted"] = is_redlisted
            info["redlistCategory"] = redlist_category

            # Set number of individuals, sex, age and activity
            if "organismQuantity" not in o["occurrence"].keys():
                if "individualCount" not in o["occurrence"].keys():
                    info["number"] = "?"
                else:
                    info["number"] = o["occurrence"]["individualCount"]
            else:
                info["number"] = o["occurrence"]["organismQuantity"]

            if "sex" in o["occurrence"]:
                sex = o["occurrence"]["sex"]["id"]
                info["sex"] = artportalen.vocabulary_sex[sex]
            else:
                info["sex"] = None
            if "lifeStage" in o["occurrence"]:
                info["age"] = o["occurrence"]["lifeStage"]["value"]
            else:
                info["age"] = None
            if "activity" in o["occurrence"]:
                info["activity"] = o["occurrence"]["activity"]["value"]
            else:
                info["activity"] = None

            # Set locality info
            info["locality"] = locality
            info["longitude"] = None
            info["latitude"] = None

            # Set URL to observation info at source
            info["data_source_observation_url"] = o["occurrence"]["occurrenceId"]

        # Add the rarity level according to some model not yet decided!
        # TBD
#        if info["name"] == "Ringnäbbad mås":
#            info["rarity"] = 10
#        else:
#            info["rarity"] = 1

        result.append(info)
    return result


def observations_for_presentation(area_name: str, observations_date):
    """Dictionary with observations for the given `observations_date` (in "YYYY--MM-DD" format) and
       all attribute values needed for the Jinja2 template file
       "hx-observations-list.html" to render HTML."""
    previous_date = (observations_date - timedelta(days=1)).isoformat()
    next_date = (observations_date + timedelta(days=1)).isoformat()

    # Get obeservations from the Artportalen API
    observations = get_observations(area_name,
                                    observations_date.isoformat(),
                                    observations_date.isoformat(),
                                    None,
                                    None)
    if not observations:
        extra = {"info": "Failed to get data on observations for a given date",
                 "date": f"{observations_date.isoformat()}"}
        logger.warning("Call to main.observations_for_presentation()",
                       extra=extra)
        observations = ["Failed"]
    else:
        # Transform the observations to representations suitable for Jinja2
        observations = transformed_observations(observations)
    return {"day": observations_date.strftime('%A, %-d/%-m').capitalize(),
            "is_today": observations_date == dt.today(),
            "year": observations_date.year,
            "previous_date": previous_date,
            "date": observations_date.isoformat(),
            "next_date": next_date,
            "observations": observations}


# Set up FastAPI
@asynccontextmanager
async def lifespan(app: FastAPI):
    settings = Settings()
    setup_logging(settings.LOGGING_CONFIG_FILE)
    logger.info("Starting Microbirding app")
    s = f"Release: {release_tag()}, Built: {build_datetime_tag()}, Git hash: {git_hash_tag()}"
    logger.info(s)
    app.state.settings = settings
    yield
    logging.info("Stopping Microbirding app")

app = FastAPI(title="Microbirding webapp",
              version=settings.VERSION,
              lifespan=lifespan)
ASSETS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "assets")
app.mount("/app/assets", StaticFiles(directory=str(ASSETS_DIR)), name="assets")


# The application resources

@app.get("/", response_class=HTMLResponse)
def get_index_file(request: Request, date: str = Query(None), index_page: str = Query(None)):
    """The main application page (page-observations.html) with observations for the given `date`.
        The `index_page` query parameter is a development for easily chosing which Jinja2 template
       to use as the index_page."""
    tic = time.perf_counter_ns()

    # TBD: Redirect to this page removing unrecognized query parameters or simply remove them by
    # pushing a path that only contains the valid query parameters.

    if not date:
        today = dt.today().isoformat()
        url = request.url.include_query_params(date=today)
        return RedirectResponse(str(url), status_code=status.HTTP_307_TEMPORARY_REDIRECT)

    if not index_page:
        index_page = "./observations/page-observations.html"

    # Figure out which date to get observations for
    if date:
        try:
            observations_date = dt.fromisoformat(date)
            if observations_date > dt.today():
                return RedirectResponse(url="/", status_code=status.HTTP_302_FOUND)
        except ValueError:
            # Redirect to root without query parameters
            return RedirectResponse(url="/", status_code=status.HTTP_302_FOUND)
    else:
        observations_date = dt.today()

    area_name = "SthlmBetong"
    obs = observations_for_presentation(area_name, observations_date)
    print(settings.UMAMI_WEBSITE_ID)
    result = templates.TemplateResponse(index_page,
                                        {"request": request,
                                         "day": obs["day"],
                                         "year": observations_date.year,
                                         "is_today": obs["is_today"],
                                         "previous_date": obs["previous_date"],
                                         "date": obs["date"],
                                         "next_date": obs["next_date"],
                                         "observations": obs["observations"],
                                         "version_info": {"release": release_tag(),
                                                          "built": build_datetime_tag(),
                                                          "git_hash": git_hash_tag()},
                                         "environment": settings.ENVIRONMENT,
                                         "umami_website_id": settings.UMAMI_WEBSITE_ID})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


@app.get("/changelog", response_class=HTMLResponse)
def get_changelog(request: Request):
    """The changelog page page (page-changelog.html) displaying the version and changelog history
       of the app."""
    tic = time.perf_counter_ns()

    markdown = mistune_markdown_instance(disabled=True)

    with open("./CHANGELOG.md") as f:
        html = markdown(f.read())
    result = templates.TemplateResponse("./about/page-changelog.html",
                                        {"request": request,
                                         "changelog_html": html,
                                         "version_info": {"release": release_tag(),
                                                          "built": build_datetime_tag(),
                                                          "git_hash": git_hash_tag()},
                                         "environment": settings.ENVIRONMENT,
                                         "umami_website_id": settings.UMAMI_WEBSITE_ID})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


@app.get("/maps", response_class=HTMLResponse)
def get_maps(request: Request):
    """The maps page (page-maps.html) displaying the map of SthlmBetong."""
    tic = time.perf_counter_ns()

    result = templates.TemplateResponse("./maps/page-maps.html",
                                        {"request": request,
                                         "version_info": {"release": release_tag(),
                                                          "built": build_datetime_tag(),
                                                          "git_hash": git_hash_tag()},
                                         "environment": settings.ENVIRONMENT,
                                         "umami_website_id": settings.UMAMI_WEBSITE_ID})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


SWEDISH_MONTHS = ["jan", "feb", "mar", "apr", "maj", "jun",
                  "jul", "aug", "sep", "okt", "nov", "dec"]
SWEDISH_RARITY_CATEGORIES = {"Very common": "M. vanlig",
                             "Common": "Vanlig",
                             "Uncommon": "Ovanlig",
                             "Rare": "Sällsynt",
                             "Very rare": "M. sällsynt"}


def format_mm_dd_swedish(mm_dd: str) -> str:
    """Change dates from MM-DD to numerical day of the month followed by the initial three letters
       of the name of the month in Swedish."""
    dt = dtime.strptime(f"2000-{mm_dd}", "%Y-%m-%d")
    return f"{dt.day} {SWEDISH_MONTHS[dt.month - 1]}"


def dummy_species_data():
    """Dummy species data."""
#    {"name": "Skrattmås",
#     "observations": 10164,
#     "earliest_date": "1950-07-21",
#     "latest_date": "2026-01-06",
#     "earliest_date_any_year": "01-01",
#     "median_earliest_date_per_year": "01-01",
#     "avg_earliest_date_per_year": "01-21",
#     "latest_date_any_year": "12-31",
#     "median_latest_date_per_year": "12-18",
#     "avg_latest_date_per_year": "09-29",
#     "rarity_classification": "TBD"}
    species = []
    with open("./data/test/sthlmbetong-1800-01-01--2026-01-06-summering.2.csv",
              newline="",
              encoding="utf-8") as f:
        reader = csv.DictReader(f, delimiter=";")
        for row in reader:
            # Convert numeric fields if needed
            row["name"] = row["taxon.vernacularName"]
            obs = int(row["observations"])
            # Change rarity category to Swedish
            row["rarity_classification"] = SWEDISH_RARITY_CATEGORIES[row["rarity_classification"]]
            # Put spaces between every group of three digits
            row["observations"] = f"{obs:,}".replace(",", " ")
            d = format_mm_dd_swedish(row["earliest_date_any_year"])
            row["earliest_date_any_year"] = d
            d = format_mm_dd_swedish(row["median_earliest_date_per_year"])
            row["median_earliest_date_per_year"] = d
            d = format_mm_dd_swedish(row["avg_earliest_date_per_year"])
            row["avg_earliest_date_per_year"] = d
            d = format_mm_dd_swedish(row["latest_date_any_year"])
            row["latest_date_any_year"] = d
            d = format_mm_dd_swedish(row["median_latest_date_per_year"])
            row["median_latest_date_per_year"] = d
            d = format_mm_dd_swedish(row["avg_latest_date_per_year"])
            row["avg_latest_date_per_year"] = d
            species.append(row)
    return species


@app.get("/species", response_class=HTMLResponse)
def get_species(request: Request):
    """The species page (page-species.html) displaying info on all species that have been observed
       in the area."""
    tic = time.perf_counter_ns()

    species = dummy_species_data()

    result = templates.TemplateResponse("./species/page-species.html",
                                        {"request": request,
                                         "species": species,
                                         "version_info": {"release": release_tag(),
                                                          "built": build_datetime_tag(),
                                                          "git_hash": git_hash_tag()},
                                         "environment": settings.ENVIRONMENT,
                                         "umami_website_id": settings.UMAMI_WEBSITE_ID})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


@app.get("/about", response_class=HTMLResponse)
async def about_root():
    """The root resource for the about pages. Redirects to the default about page."""
    return RedirectResponse(
        url=f"/about/{settings.ABOUT_DEFAULT_SLUG}",
        status_code=307
    )


@app.get("/about/{slug}", response_class=HTMLResponse)
def get_about(request: Request, slug: str):
    """The about page (page-about.html) with information on the app."""
    tic = time.perf_counter_ns()

    if slug not in settings.ABOUT_SECTIONS:
        raise HTTPException(status_code=404, detail="Unknown section")

    markdown = mistune_markdown_instance(disabled=True)
    md_path = os.path.join(settings.ABOUT_CONTENT_DIRECTORY, settings.ABOUT_SECTIONS[slug])
    if not os.path.exists(md_path):
        raise HTTPException(status_code=500, detail="Missing content file")
    with open(md_path) as f:
        html = markdown(f.read())

    result = templates.TemplateResponse(
        "./about/page-about.html",
        {
            "request": request,
            "active_slug": slug,
            "section_html": html,
            "version_info": {"release": release_tag(),
                             "built": build_datetime_tag(),
                             "git_hash": git_hash_tag()},
            "environment": settings.ENVIRONMENT,
            "umami_website_id": settings.UMAMI_WEBSITE_ID
        },
    )

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


@app.get("/design-system", response_class=HTMLResponse)
def get_design_system(request: Request):
    """The design system page (page-design-system.html) displaying UI stuff used in the app."""
    tic = time.perf_counter_ns()

    # We want to display an observation for development and debugging purposes
    date = "2025-12-15"
    area_name = "SthlmBetong"
    observations_date = dt.fromisoformat(date)
    obs = observations_for_presentation(area_name, observations_date)
    obs_no = 5
    result = templates.TemplateResponse("./page-design-system.html",
                                        {"request": request,
                                         "o": obs["observations"][obs_no],
                                         "version_info": {"release": release_tag(),
                                                          "built": build_datetime_tag(),
                                                          "git_hash": git_hash_tag()},
                                         "environment": settings.ENVIRONMENT,
                                         "umami_website_id": settings.UMAMI_WEBSITE_ID})

    toc = time.perf_counter_ns()
    # Set Server-timing header (server excution time in ms, not including FastAPI itself)
    result.headers["Server-timing"] = f"API;dur={(toc - tic)/1000000}"
    return result


# The application hypermedia control resources.
# All of these resources have the prefix "/hx/" in their URL path.

@app.get("/hx/observations-section", response_class=HTMLResponse)
def hx_observations_section(request: Request, date: str = Query(None)):
    """The observations HTML <section> element with the observations for the given `date`."""
    # We assume we have a valid date that isn't ahead of today's date.
    observations_date = dt.fromisoformat(date)
    area_name = "SthlmBetong"
    obs = observations_for_presentation(area_name, observations_date)
    return templates.TemplateResponse("./observations/hx-observations-list.html",
                                      {"request": request,
                                       "day": obs["day"],
                                       "year": observations_date.year,
                                       "is_today": obs["is_today"],
                                       "previous_date": obs["previous_date"],
                                       "date": obs["date"],
                                       "next_date": obs["next_date"],
                                       "observations": obs["observations"],
                                       "environment": settings.ENVIRONMENT,
                                       "umami_website_id": settings.UMAMI_WEBSITE_ID})


# MapLibre GL JS resources (experimental)

@app.get("/mapping/pins")
def get_mapping_pins():
    """Get some geo pins."""
    return JSONResponse(mapping.models.some_pins())


@app.get("/mapping/areas")
def get_mapping_areas():
    """Get a geo areas."""
    geojson = mapping.geojson_area_by_name("SthlmBetong")
    return JSONResponse(geojson.dict())


@app.get("/mapping/style")
def get_map_style():
    """Get a map style."""
    style = mapping.default_maplibre_style().dict()
    # Set low TTL if data changes often
    return JSONResponse(style, headers={"Cache-Control": "no-cache"})


# The application 404 exception handler

@app.exception_handler(404)
async def not_found(request: Request, exc):
    """Render a 404 page for missing resources."""
    return templates.TemplateResponse(
        "./page-404.html",
        {
            "request": request,
            "path": request.url.path,
            "version_info": {
                "release": release_tag(),
                "built": build_datetime_tag(),
                "git_hash": git_hash_tag(),
            },
            "environment": settings.ENVIRONMENT,
            "umami_website_id": settings.UMAMI_WEBSITE_ID
        },
        status_code=404,
    )
